#!/bin/bash

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

PROJECT_NAME="customer-dashboard"
STACKS_DIR="docker/stacks"
DEFAULT_STACK="default"
COMPOSE_ARGS=""

parse_stack_services() {
    local stack_name=$1
    local stack_file="${STACKS_DIR}/${stack_name}.txt"

    if [ ! -f "$stack_file" ]; then
        printf "%bError: Stack '%s' not found in %s%b\n" "$RED" "$stack_name" "$STACKS_DIR" "$NC" >&2
        echo "Available stacks:"
        list_available_stacks
        exit 1
    fi

    grep -v '^#' "$stack_file" | grep -v '^[[:space:]]*$' | tr '\n' ' '
}

get_stack_description() {
    local stack_name=$1
    local stack_file="${STACKS_DIR}/${stack_name}.txt"

    if [ -f "$stack_file" ]; then
        # Get first comment line and remove the '# ' prefix
        head -n 1 "$stack_file" | grep '^#' | sed 's/^# *//' || echo "No description available"
    else
        echo "Stack not found"
    fi
}

list_available_stacks() {
    printf "%bAvailable stacks:%b\n" "$YELLOW" "$NC"
    for stack_file in "$STACKS_DIR"/*.txt; do
        if [ -f "$stack_file" ]; then
            local stack_name
            stack_name=$(basename "$stack_file" .txt)
            local description
            description=$(get_stack_description "$stack_name")
            printf "  %b%-12s%b %s\n" "$GREEN" "$stack_name" "$NC" "$description"
        fi
    done
}

build_compose_args() {
    local stack_name=${1:-$DEFAULT_STACK}
    local args=""

    local services
    services=$(parse_stack_services "$stack_name")

    printf "%bUsing stack '%s':%b %s\n" "$BLUE" "$stack_name" "$NC" "$(get_stack_description "$stack_name")"
    printf "%bServices:%b %s\n" "$YELLOW" "$NC" "$services"

    for service in $services; do
        if [ -f "docker/services/${service}.yml" ]; then
            args="$args -f docker/services/${service}.yml"
        else
            printf "%bError: Service file 'docker/services/${service}.yml' not found%b\n" "$RED" "$NC" >&2
            exit 1
        fi
    done

    COMPOSE_ARGS="$args"
}

show_usage() {
    printf "%bCustomer Dashboard Environment Manager%b\n" "$BLUE" "$NC"
    echo ""
    echo "Usage: $0 [COMMAND] [OPTIONS] [STACK]"
    echo ""
    printf "%bCommands:%b\n" "$YELLOW" "$NC"
    echo "  up         Start the application"
    echo "  down       Stop the application"
    echo "  restart    Restart the application"
    echo "  logs       Show application logs"
    echo "  status     Show status of running containers"
    echo "  stacks     List all available stacks"
    echo "  clean      Remove all containers, networks, and volumes"
    echo "  help       Show this help message"
    echo ""
    printf "%bOptions:%b\n" "$YELLOW" "$NC"
    echo "  -a, --attach      Run in foreground"
    echo "  -b, --build       Force rebuild of images"
    echo "  -f, --follow      Follow logs in real-time"
    echo "  -s, --stack NAME  Use specific stack (default: $DEFAULT_STACK)"
    echo ""
    printf "%bExamples:%b\n" "$YELLOW" "$NC"
    echo "  $0 up                     # Start default stack in background"
    echo "  $0 up -s minimal          # Start minimal stack"
    echo "  $0 up -a -s full          # Start full stack in foreground"
    echo "  $0 stacks                 # List all available stacks"
    echo "  $0 logs -f -s api-only    # Follow logs for api-only stack"
    echo ""
}

run_compose() {
    local command=$1
    local stack_name=$2
    shift 2
    local additional_args="$*"

    build_compose_args "$stack_name"

    local full_command="docker-compose -p ${PROJECT_NAME} $COMPOSE_ARGS $command $additional_args"

    eval "$full_command"
}

show_status() {
    printf "%bCustomer Dashboard Status%b\n" "$BLUE" "$NC"
    echo ""

    local running_containers
    running_containers=$(docker ps --filter "name=${PROJECT_NAME}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null || echo "")

    if [ -z "$running_containers" ] || [ "$(echo "$running_containers" | wc -l | tr -d ' ')" -eq 1 ]; then
        printf "%bNo containers currently running%b\n" "$YELLOW" "$NC"
        echo ""
        echo "Start the application with: $0 up"
    else
        printf "%bRunning containers:%b\n" "$GREEN" "$NC"
        echo "$running_containers"
        echo ""
    fi

    local networks
      networks=$(docker network ls --filter "name=${PROJECT_NAME}" --format "table {{.Name}}\t{{.Driver}}\t{{.Scope}}" 2>/dev/null || echo "")

    if [ -z "$networks" ]; then
        printf "%bNo active networks%b\n" "$YELLOW" "$NC"
    else
        local networks_line_count
        networks_line_count=$(echo "$networks" | wc -l | tr -d ' ')
        if [ "$networks_line_count" -eq 1 ]; then
            printf "%bNo active networks%b\n" "$YELLOW" "$NC"
        else
            printf "%bActive networks:%b\n" "$GREEN" "$NC"
            echo "$networks"
        fi
    fi

    echo ""

    local volumes
    volumes=$(docker volume ls --filter "name=${PROJECT_NAME}" --format "table {{.Name}}\t{{.Driver}}" 2>/dev/null || echo "")

    if [ -z "$volumes" ]; then
        printf "%bNo created volumes%b\n" "$YELLOW" "$NC"
    else
        local volumes_line_count
        volumes_line_count=$(echo "$volumes" | wc -l | tr -d ' ')
        if [ "$volumes_line_count" -eq 1 ]; then
            printf "%bNo created volumes%b\n" "$YELLOW" "$NC"
        else
            printf "%bCreated Volumes:%b\n" "$GREEN" "$NC"
            echo "$volumes"
        fi
    fi
}

clean_all() {
    printf "%bThis will remove all containers, networks, and volumes for all stacks.%b\n" "$YELLOW" "$NC"
    printf "%bThis action cannot be undone!%b\n" "$RED" "$NC"
    echo ""
    printf "Are you sure? (y/N): "
    read -r REPLY

    case "$REPLY" in
        [Yy]|[Yy][Ee][Ss])
            printf "%bCleaning up all stacks...%b\n" "$BLUE" "$NC"

            # Clean up containers for all possible stacks
            for stack_file in "$STACKS_DIR"/*.txt; do
                if [ -f "$stack_file" ]; then
                    local stack_name
                    stack_name=$(basename "$stack_file" .txt)
                    printf "Cleaning stack: %s\n" "$stack_name"
                    run_compose "down" "$stack_name" "--remove-orphans --volumes" 2>/dev/null || true
                fi
            done

            # Additional cleanup
            docker container prune --filter "name=${PROJECT_NAME}" -f 2>/dev/null || true
            docker network prune --filter "name=${PROJECT_NAME}" -f 2>/dev/null || true
            docker volume prune --filter "name=${PROJECT_NAME}" -f 2>/dev/null || true
            printf "%bCleanup complete!%b\n" "$GREEN" "$NC"
            ;;
        *)
            echo "Cancelled."
            ;;
    esac
}

if [ ! -d "$STACKS_DIR" ]; then
    printf "%bError: Stacks directory '%s' not found%b\n" "$RED" "$STACKS_DIR" "$NC" >&2
    exit 1
fi

ATTACH=false
BUILD=false
FOLLOW=false
STACK_NAME="$DEFAULT_STACK"
COMMAND=""

while [ $# -gt 0 ]; do
    case $1 in
        up|down|restart|logs|build|pull)
            COMMAND=$1
            shift
            ;;
        status|stacks|clean|help)
            COMMAND=$1
            shift
            break
            ;;
        -a|--attach)
            ATTACH=true
            shift
            ;;
        -b|--build)
            BUILD=true
            shift
            ;;
        -f|--follow)
            FOLLOW=true
            shift
            ;;
        -s|--stack)
            if [ -n "$2" ]; then
                STACK_NAME="$2"
                shift 2
            else
                printf "%bError: --stack requires a stack name%b\n" "$RED" "$NC" >&2
                exit 1
            fi
            ;;
        -*)
            printf "%bError: Unknown option %s%b\n" "$RED" "$1" "$NC" >&2
            show_usage
            exit 1
            ;;
        *)
            if [ -z "$COMMAND" ]; then
                printf "%bError: Unknown command '%s'%b\n" "$RED" "$1" "$NC" >&2
                show_usage
                exit 1
            fi
            ;;
    esac
done

# Execute commands
case ${COMMAND:-} in
    stacks)
        list_available_stacks
        ;;
    status)
        show_status
        ;;
    clean)
        clean_all
        ;;
    help|"")
        show_usage
        ;;
    up)
        ADDITIONAL_ARGS=""
        [ "$ATTACH" = "false" ] && ADDITIONAL_ARGS="$ADDITIONAL_ARGS -d"
        [ "$BUILD" = "true" ] && ADDITIONAL_ARGS="$ADDITIONAL_ARGS --build"

        printf "%bStarting application...%b\n" "$GREEN" "$NC"
        run_compose "up" "$STACK_NAME" "$ADDITIONAL_ARGS"

        if [ "$ATTACH" = "false" ]; then
            echo ""
            printf "%bApplication started!%b\n" "$GREEN" "$NC"
        fi
        ;;
    down)
        printf "%bStopping application...%b\n" "$YELLOW" "$NC"
        run_compose "down" "$STACK_NAME"
        ;;
    restart)
        printf "%bRestarting application...%b\n" "$YELLOW" "$NC"
        run_compose "restart" "$STACK_NAME"
        ;;
    logs)
        ADDITIONAL_ARGS=""
        [ "$FOLLOW" = "true" ] && ADDITIONAL_ARGS="$ADDITIONAL_ARGS -f"
        run_compose "logs" "$STACK_NAME" "$ADDITIONAL_ARGS"
        ;;
    build)
        printf "%bBuilding application...%b\n" "$BLUE" "$NC"
        run_compose "build" "$STACK_NAME"
        ;;
    pull)
        printf "%bPulling images...%b\n" "$BLUE" "$NC"
        run_compose "pull" "$STACK_NAME"
        ;;
    *)
        printf "%bError: Unknown command '%s'%b\n" "$RED" "$COMMAND" "$NC" >&2
        show_usage
        exit 1
        ;;
esac